{"version":3,"file":"index.mjs","sources":["../src/primitives.ts","../src/util.ts","../src/reference.ts","../src/box.ts","../src/state.ts","../src/itxn.ts","../src/itxn-compose.ts","../src/gtxn.ts","../src/transactions.ts","../src/logic-sig.ts","../src/template-var.ts","../src/compiled.ts","../src/reference-array.ts","../src/arc-28.ts","../src/on-complete-action.ts","../src/arrays.ts"],"sourcesContent":["import { NoImplementation } from './internal/errors'\n\n/**\n * An alias for types which can be converted to a uint64\n */\nexport type Uint64Compat = uint64 | bigint | boolean | number\n/**\n * An alias for types which can be converted to a biguint\n */\nexport type BigUintCompat = bigint | bytes | number | boolean\n/**\n * An alias for types which can be converted to a string\n */\nexport type StringCompat = string\n/**\n * An alias for types which can be converted to a bytes sequence\n */\nexport type BytesCompat = bytes | string\n\n/**\n * An unsigned integer of exactly 64 bits\n */\nexport type uint64 = {\n  /**\n   * @hidden\n   */\n  __type?: 'uint64'\n} & number\n\n/**\n * Create a uint64 with the default value of 0\n */\nexport function Uint64(): uint64\n/**\n * Create a uint64 from a string literal\n */\nexport function Uint64(v: string): uint64\n/**\n * Create a uint64 from a bigint literal\n */\nexport function Uint64(v: bigint): uint64\n/**\n * Create a uint64 from a number literal\n */\nexport function Uint64(v: number): uint64\n/**\n * Create a uint64 from a boolean value. True is 1, False is 0\n */\nexport function Uint64(v: boolean): uint64\nexport function Uint64(v?: Uint64Compat | string): uint64 {\n  throw new NoImplementation()\n}\n\nUint64.MAX_VALUE = NoImplementation.value<uint64>()\nUint64.MIN_VALUE = NoImplementation.value<uint64>()\n\n/**\n * An unsigned integer of up to 512 bits\n *\n * Stored as a big-endian variable byte array\n */\nexport type biguint = {\n  /**\n   * @hidden\n   */\n  __type?: 'biguint'\n} & bigint\n\n/**\n * Create a biguint from a bigint literal\n */\nexport function BigUint(v: bigint): biguint\n/**\n * Create a biguint from a boolean value (true = 1, false = 0)\n */\nexport function BigUint(v: boolean): biguint\n/**\n * Create a biguint from a uint64 value\n */\nexport function BigUint(v: uint64): biguint\n/**\n * Create a biguint from a number literal\n */\nexport function BigUint(v: number): biguint\n/**\n * Create a biguint from a byte array interpreted as a big-endian number\n */\nexport function BigUint(v: bytes): biguint\n/**\n * Create a biguint from a string literal containing the decimal digits\n */\nexport function BigUint(v: string): biguint\n/**\n * Create a biguint with the default value of 0\n */\nexport function BigUint(): biguint\nexport function BigUint(v?: BigUintCompat | string): biguint {\n  throw new NoImplementation()\n}\n\ntype ToFixedBytesOptions<TLength extends uint64 = uint64> = {\n  /**\n   * The length for the bounded type\n   */\n  length: TLength\n  /**\n   * The strategy to use for converting to a fixed length bytes type (default: 'assert-length')\n   *\n   * - 'assert-length': Asserts that the byte sequence has the specified length and fails if it differs\n   * - 'unsafe-cast': Reinterprets the byte sequence as a fixed length type without any checks. This will succeed even if the value\n   *              is not of the specified length but will result in undefined behaviour for any code that makes use of this value.\n   *\n   */\n  strategy?: 'assert-length' | 'unsafe-cast'\n}\n/**\n * A sequence of zero or more bytes (ie. byte[])\n *\n * @typeParam TLength The static length of this byte array\n */\nexport type bytes<out TLength extends uint64 = uint64> = {\n  /**\n   * Retrieve the length of the byte sequence\n   */\n  readonly length: uint64\n\n  /**\n   * Retrieve the byte at the index i\n   * @param i The index to read. Can be negative to read from the end\n   * @returns The byte found at the index, or an empty bytes value\n   */\n  at(i: Uint64Compat): bytes\n\n  /**\n   * Concatenate this bytes value with another bytes value\n   * @param other The other bytes value\n   * @returns The concatenation result\n   */\n  concat(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise AND operation with this bytes value and another bytes value\n   * of the same length.\n   *\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseAnd(other: bytes<TLength>): bytes<TLength>\n\n  /**\n   * Perform a bitwise AND operation with this bytes value and another bytes value.\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseAnd(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise OR operation with this bytes value and another bytes value\n   * of the same length.\n   *\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseOr(other: bytes<TLength>): bytes<TLength>\n\n  /**\n   * Perform a bitwise OR operation with this bytes value and another bytes value\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseOr(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise XOR operation with this bytes value and another bytes value\n   * of the same length.\n   *\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseXor(other: bytes<TLength>): bytes<TLength>\n\n  /**\n   * Perform a bitwise XOR operation with this bytes value and another bytes value.\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseXor(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise INVERT operation with this bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseInvert(): bytes<TLength>\n\n  /**\n   * Compares this bytes value with another.\n   * @param other The other bytes value\n   * @returns True if both values represent the same byte sequence\n   */\n  equals(other: BytesCompat): boolean\n\n  /**\n   * Returns a copy of this bytes sequence\n   */\n  slice(): bytes<TLength>\n  /**\n   * Returns a slice of this bytes sequence from the specified start to the end\n   * @param start The index to start slicing from. Can be negative to count from the end.\n   */\n  slice(start: Uint64Compat): bytes\n  /**\n   * Returns a slice of this bytes sequence from the specified start to the specified end\n   * @param start The index to start slicing from. Can be negative to count from the end.\n   * @param end The index to end the slice. Can be negative to count from the end.\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): bytes\n  /**\n   * @hidden\n   */\n  slice(start?: Uint64Compat, end?: Uint64Compat): bytes\n\n  /**\n   * Interpret this byte sequence as a utf-8 string\n   */\n  toString(): string\n\n  /**\n   * Change this unbounded bytes instance into a bounded one\n   * @param options Options for the conversion\n   */\n  toFixed<TNewLength extends TLength>(options: ToFixedBytesOptions<TNewLength>): bytes<TNewLength>\n}\n\n/**\n * Create a byte array from a string interpolation template and compatible replacements\n * @param value\n * @param replacements\n */\nexport function Bytes(value: TemplateStringsArray, ...replacements: BytesCompat[]): bytes<uint64>\n/**\n * Create a byte array from a utf8 string\n */\nexport function Bytes(value: string): bytes<uint64>\n/**\n * Create a byte array from a utf8 string\n */\nexport function Bytes<TLength extends uint64>(value: string, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n/**\n * No op, returns the provided byte array.\n */\nexport function Bytes(value: bytes): bytes<uint64>\n/**\n * No op, returns the provided byte array.\n */\nexport function Bytes<TLength extends uint64>(value: bytes, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n/**\n * Create a byte array from a biguint value encoded as a variable length big-endian number\n */\nexport function Bytes(value: biguint): bytes<uint64>\n/**\n * Create a byte array from a biguint value encoded as a variable length big-endian number\n */\nexport function Bytes<TLength extends uint64>(value: biguint, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n/**\n * Create a byte array from a uint64 value encoded as a a variable length 64-bit number\n */\nexport function Bytes(value: uint64): bytes<uint64>\n/**\n * Create a byte array from a uint64 value encoded as a a variable length 64-bit number\n */\nexport function Bytes<TLength extends uint64 = 8>(value: uint64, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n/**\n * Create a byte array from an Iterable<uint64> where each item is interpreted as a single byte and must be between 0 and 255 inclusively\n */\nexport function Bytes(value: Iterable<uint64>): bytes<uint64>\n/**\n * Create a byte array from an Iterable<uint64> where each item is interpreted as a single byte and must be between 0 and 255 inclusively\n */\nexport function Bytes<TLength extends uint64>(value: Iterable<uint64>, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n/**\n * Create an empty byte array\n */\nexport function Bytes(): bytes<uint64>\n/**\n * Create an empty byte array\n */\nexport function Bytes<TLength extends uint64 = uint64>(options: ToFixedBytesOptions<TLength>): bytes<TLength>\nexport function Bytes<TLength extends uint64 = uint64>(\n  value?: BytesCompat | TemplateStringsArray | biguint | uint64 | Iterable<number> | ToFixedBytesOptions<TLength>,\n  ...replacements: [ToFixedBytesOptions<TLength>] | BytesCompat[] | undefined[]\n): bytes<TLength> {\n  throw new NoImplementation()\n}\n\nexport namespace Bytes {\n  /**\n   * Create a new bytes value from a hexadecimal encoded string\n   * @param hex A literal string of hexadecimal characters\n   */\n  export function fromHex(hex: string): bytes<uint64>\n  /**\n   * Create a new bytes value from a hexadecimal encoded string\n   * @param hex A literal string of hexadecimal characters\n   * @param options Options for bounded bytes\n   */\n  export function fromHex<TLength extends uint64>(hex: string, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n  export function fromHex<TLength extends uint64 = uint64>(hex: string, options?: ToFixedBytesOptions<TLength>): bytes<TLength> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Create a new bytes value from a base 64 encoded string\n   * @param b64 A literal string of b64 encoded characters\n   */\n  export function fromBase64(b64: string): bytes<uint64>\n  /**\n   * Create a new bytes value from a base 64 encoded string\n   * @param b64 A literal string of b64 encoded characters\n   * @param options Options for bounded bytes\n   */\n  export function fromBase64<TLength extends uint64>(b64: string, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n  export function fromBase64<TLength extends uint64 = uint64>(b64: string, options?: ToFixedBytesOptions<TLength>): bytes<TLength> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Create a new bytes value from a base 32 encoded string\n   * @param b32 A literal string of b32 encoded characters\n   */\n  export function fromBase32(b32: string): bytes<uint64>\n  /**\n   * Create a new bytes value from a base 32 encoded string\n   * @param b32 A literal string of b32 encoded characters\n   * @param options Options for bounded bytes\n   */\n  export function fromBase32<TLength extends uint64>(b32: string, options: ToFixedBytesOptions<TLength>): bytes<TLength>\n  export function fromBase32<TLength extends uint64 = uint64>(b32: string, options?: ToFixedBytesOptions<TLength>): bytes<TLength> {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * An interface for types which are backed by the AVM bytes type\n */\nexport interface BytesBacked<TLength extends uint64 = uint64> {\n  /**\n   * Retrieve the underlying bytes representing this value\n   */\n  get bytes(): bytes<TLength>\n}\n\n/**\n * Declare a homogeneous tuple with the item type T and length N.\n *\n * Eg.\n * NTuple<uint64, 3> === [uint64, uint64, uint64]\n */\nexport type NTuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, readonly []>) : never\n\ntype _TupleOf<T, N extends number, R extends readonly unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, readonly [T, ...R]>\n","import { NoImplementation } from './internal/errors'\nimport { biguint, BigUintCompat, BytesBacked, BytesCompat, StringCompat, uint64, Uint64Compat } from './primitives'\n\n/**\n * Write one or more values to the transaction log.\n *\n * Each value is converted to bytes and concatenated\n * @param args The values to write\n */\nexport function log(...args: Array<Uint64Compat | BytesCompat | BigUintCompat | StringCompat | BytesBacked>): void {\n  throw new NoImplementation()\n}\n\n/**\n * Asserts that `condition` is truthy, otherwise error and halt execution.\n * @param condition An expression that can be evaluated as truthy of falsy\n * @param message The message to show if `condition` is falsy and an error is raised.\n */\nexport function assert(condition: unknown, message?: string): asserts condition {\n  throw new NoImplementation()\n}\n\n/**\n * Raise an error and halt execution\n * @param message The message to accompany the error\n */\nexport function err(message?: string): never {\n  throw new NoImplementation()\n}\n\n/**\n * Defines possible comparison expressions for numeric types\n */\ntype NumericComparison<T> =\n  | T\n  | {\n      /**\n       * Is the subject less than the specified value\n       */\n      lessThan: T\n    }\n  | {\n      /**\n       * Is the subject greater than the specified value\n       */\n      greaterThan: T\n    }\n  | {\n      /**\n       * Is the subject greater than or equal to the specified value\n       */\n      greaterThanEq: T\n    }\n  | {\n      /**\n       * Is the subject less than or equal to the specified value\n       */\n      lessThanEq: T\n    }\n  | {\n      /**\n       * Is the subject between the specified values (inclusive)\n       */\n      between: readonly [T, T]\n    }\n  | {\n      /**\n       * Is the subject not equal to the specified value\n       */\n      not: T\n    }\n\n/**\n * Defines possible comparison expressions for non-numeric types\n */\ntype NonNumericComparison<T> =\n  | T\n  | {\n      /**\n       * Is the subject not equal to the specified value\n       */\n      not: T\n    }\n\n/**\n * Returns compatible comparison expressions for a type `T`\n * @typeParam T The type requiring comparison\n */\ntype ComparisonFor<T> = T extends uint64 | biguint ? NumericComparison<T> : NonNumericComparison<T>\n\n/**\n * A set of tests to apply to the match subject\n * @typeParam T The type of the test subject\n */\ntype MatchTest<T> =\n  T extends ConcatArray<infer TItem>\n    ? { [index: number]: ComparisonFor<TItem> } & {\n        length?: ComparisonFor<uint64>\n      }\n    : {\n        [key in keyof T]?: ComparisonFor<T[key]>\n      }\n\n/**\n * Applies all tests in `test` against `subject` and returns a boolean indicating if they all pass\n * @param subject An object or tuple to be tested\n * @param test An object containing one or more tests to be applied to the subject\n * @typeParam T The type of the subject\n * @returns True if all tests pass, otherwise false\n */\nexport function match<T>(subject: T, test: MatchTest<T>): boolean {\n  throw new NoImplementation()\n}\n\n/**\n *\n * Applies all tests in `test` against `subject` and asserts they all pass\n * @param subject An object or tuple to be tested\n * @param test An object containing one or more tests to be applied to the subject\n * @param message An optional message to show if the assertion fails\n * @typeParam T The type of the subject\n */\nexport function assertMatch<T>(subject: T, test: MatchTest<T>, message?: string): void {\n  throw new NoImplementation()\n}\n\n/**\n * Defines the source of fees for the OpUp utility\n */\nexport enum OpUpFeeSource {\n  /**\n   * Only the excess fee (credit) on the outer group should be used (itxn.fee = 0)\n   */\n  GroupCredit = 0,\n  /**\n   * The app's account will cover all fees (itxn.fee = Global.minTxFee)\n   */\n  AppAccount = 1,\n  /**\n   * First the excess will be used, then remaining fees taken from the app account\n   */\n  Any = 2,\n}\n\n/**\n * Ensure the available op code budget is greater than or equal to requiredBudget.\n *\n * This is done by adding AppCall itxns to the group to increase the available budget. These itxns must be paid for\n * by the caller or the application.\n * @param requiredBudget The total required budget\n * @param feeSource Which source to withdraw txn fees from.\n */\nexport function ensureBudget(requiredBudget: uint64, feeSource: OpUpFeeSource = OpUpFeeSource.GroupCredit) {\n  throw new NoImplementation()\n}\n\n/**\n * Generates an iterable sequence from 0...stop inclusive\n * @param stop The stop number of the sequence\n */\nexport function urange(stop: Uint64Compat): IterableIterator<uint64>\n/**\n * Generates an iterable sequence from start...stop inclusive\n * @param start The start number of the sequence\n * @param stop The stop number of the sequence\n */\nexport function urange(start: Uint64Compat, stop: Uint64Compat): IterableIterator<uint64>\n/**\n * Generates an iterable sequence from start...stop inclusive with increments of size step\n * @param start The start number of the sequence\n * @param stop The stop number of the sequence\n * @param step The step size of the sequence\n */\nexport function urange(start: Uint64Compat, stop: Uint64Compat, step: Uint64Compat): IterableIterator<uint64>\nexport function urange(a: Uint64Compat, b?: Uint64Compat, c?: Uint64Compat): IterableIterator<uint64> {\n  throw new NoImplementation()\n}\n\n/**\n * Defines a numeric range including all numbers between from and to\n */\nexport type NumberRange = { from: number; to: number }\n\n/**\n * Creates a deep copy of the specified value\n * @param value The value to clone\n */\nexport function clone<T>(value: T): T {\n  throw new NoImplementation()\n}\n\n/**\n * Performs validation to ensure the value is well-formed, errors if it is not\n * @param value The value to validate\n *\n */\nexport function validateEncoding<T>(value: T) {\n  throw new NoImplementation()\n}\n","import { NoImplementation } from './internal/errors'\nimport { bytes, uint64 } from './primitives'\n\n/**\n * Represents an Algorand Account and exposes properties and methods for reading account data\n */\nexport type Account = {\n  /**\n   * Get the accounts address in bytes\n   */\n  readonly bytes: bytes<32>\n\n  /**\n   * Account balance in microalgos\n   *\n   * Account must be an available resource\n   */\n  readonly balance: uint64\n\n  /**\n   * Minimum required balance for account, in microalgos\n   *\n   * Account must be an available resource\n   */\n  readonly minBalance: uint64\n\n  /**\n   * Address the account is rekeyed to\n   *\n   * Account must be an available resource\n   */\n  readonly authAddress: Account\n\n  /**\n   * The total number of uint64 values allocated by this account in Global and Local States.\n   *\n   * Account must be an available resource\n   */\n  readonly totalNumUint: uint64\n\n  /**\n   * The total number of byte array values allocated by this account in Global and Local States.\n   *\n   * Account must be an available resource\n   */\n  readonly totalNumByteSlice: uint64\n\n  /**\n   * The number of extra app code pages used by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalExtraAppPages: uint64\n\n  /**\n   * The number of existing apps created by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAppsCreated: uint64\n\n  /**\n   * The number of apps this account is opted into.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAppsOptedIn: uint64\n\n  /**\n   * The number of existing ASAs created by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAssetsCreated: uint64\n\n  /**\n   * The numbers of ASAs held by this account (including ASAs this account created).\n   *\n   * Account must be an available resource\n   */\n  readonly totalAssets: uint64\n\n  /**\n   * The number of existing boxes created by this account's app.\n   *\n   * Account must be an available resource\n   */\n  readonly totalBoxes: uint64\n\n  /**\n   * The total number of bytes used by this account's app's box keys and values.\n   *\n   * Account must be an available resource\n   */\n  readonly totalBoxBytes: uint64\n\n  /**\n   * Returns true if this account is opted in to the specified Asset or Application.\n   * Note: Account and Asset/Application must be an available resource\n   *\n   * @param assetOrApp\n   */\n  isOptedIn(assetOrApp: Asset | Application): boolean\n}\n\n/**\n * Create a new account object representing the zero address\n */\nexport function Account(): Account\n/**\n * Create a new account object representing the provided public key bytes\n * @param publicKey A 32-byte Algorand account public key\n */\nexport function Account(publicKey: bytes): Account\n/**\n * Create a new account object representing the provided address\n * @param address A 56 character base-32 encoded Algorand address\n */\nexport function Account(address: string): Account\nexport function Account(publicKeyOrAddress?: bytes | string): Account {\n  throw new NoImplementation()\n}\n\n/**\n * Creates a new Asset object represent the asset id 0 (an invalid ID)\n */\nexport function Asset(): Asset\n/**\n * Creates a new Asset object representing the asset with the specified id\n * @param assetId The id of the asset\n */\nexport function Asset(assetId: uint64): Asset\nexport function Asset(assetId?: uint64): Asset {\n  throw new NoImplementation()\n}\n/**\n * An Asset on the Algorand network.\n */\nexport type Asset = {\n  /**\n   * Returns the id of the Asset\n   */\n  readonly id: uint64\n\n  /**\n   * Total number of units of this asset\n   */\n  readonly total: uint64\n\n  /**\n   * @see AssetParams.decimals\n   */\n  readonly decimals: uint64\n\n  /**\n   * Frozen by default or not\n   */\n  readonly defaultFrozen: boolean\n\n  /**\n   * Asset unit name\n   */\n  readonly unitName: bytes\n\n  /**\n   * Asset name\n   */\n  readonly name: bytes\n\n  /**\n   * URL with additional info about the asset\n   */\n  readonly url: bytes\n\n  /**\n   * Arbitrary commitment\n   */\n  readonly metadataHash: bytes<32>\n\n  /**\n   * Manager address\n   */\n  readonly manager: Account\n\n  /**\n   * Reserve address\n   */\n  readonly reserve: Account\n\n  /**\n   * Freeze address\n   */\n  readonly freeze: Account\n\n  /**\n   * Clawback address\n   */\n  readonly clawback: Account\n\n  /**\n   * Creator address\n   */\n  readonly creator: Account\n\n  /**\n   * Amount of the asset unit held by this account. Fails if the account has not\n   * opted in to the asset.\n   * Asset and supplied Account must be an available resource\n   * @param account Account\n   * @return balance: uint64\n   */\n  balance(account: Account): uint64\n\n  /**\n   * Is the asset frozen or not. Fails if the account has not\n   * opted in to the asset.\n   * Asset and supplied Account must be an available resource\n   * @param account Account\n   * @return isFrozen: boolean\n   */\n  frozen(account: Account): boolean\n}\n\n/**\n * Creates a new Application object represent the application id 0 (an invalid ID)\n */\nexport function Application(): Application\n/**\n * Creates a new Application object representing the application with the specified id\n * @param applicationId The id of the application\n */\nexport function Application(applicationId: uint64): Application\nexport function Application(applicationId?: uint64): Application {\n  throw new NoImplementation()\n}\n\n/**\n * An Application on the Algorand network.\n */\nexport type Application = {\n  /**\n   * The id of this application on the current network\n   */\n  readonly id: uint64\n  /**\n   * Bytecode of Approval Program\n   */\n  readonly approvalProgram: bytes\n\n  /**\n   * Bytecode of Clear State Program\n   */\n  readonly clearStateProgram: bytes\n\n  /**\n   * Number of uint64 values allowed in Global State\n   */\n  readonly globalNumUint: uint64\n\n  /**\n   * Number of byte array values allowed in Global State\n   */\n  readonly globalNumBytes: uint64\n\n  /**\n   * Number of uint64 values allowed in Local State\n   */\n  readonly localNumUint: uint64\n\n  /**\n   * Number of byte array values allowed in Local State\n   */\n  readonly localNumBytes: uint64\n\n  /**\n   * Number of Extra Program Pages of code space\n   */\n  readonly extraProgramPages: uint64\n\n  /**\n   * Creator address\n   */\n  readonly creator: Account\n\n  /**\n   * Address for which this application has authority\n   */\n  readonly address: Account\n\n  /**\n   * Version of the app, incremented each time the approval or clear program changes\n   */\n  readonly version: uint64\n}\n","import { NoImplementation } from './internal/errors'\nimport { bytes, uint64 } from './primitives'\n\n/**\n * A Box proxy\n * @typeParam TValue The type of the data stored in the box.\n */\nexport type Box<TValue> = {\n  /**\n   * Create the box for this proxy with a bzero value.\n   *  - If options.size is specified, the box will be created with that length\n   *  - Otherwise the box will be created with storage size of TValue. Errors if the size of TValue is not fixed\n   *\n   * No op if the box already exists with the same size\n   * Errors if the box already exists with a different size.\n   * Errors if the specified size is greater than the max box size (32,768)\n   * @returns True if the box was created, false if it already existed\n   */\n  create(options?: { size?: uint64 }): boolean\n  /**\n   * Get the key used by this box proxy\n   */\n  readonly key: bytes\n  /**\n   * Get or set the value stored in the box\n   *\n   * Get will error if the box does not exist\n   */\n  value: TValue\n  /**\n   * Get a boolean indicating if the box exists or not\n   */\n  readonly exists: boolean\n  /**\n   * Get the value stored in the box, or return a specified default value if the box does not exist\n   * @param options Options to specify a default value to be returned if no other value exists\n   * @returns The value if the box exists, else the default value\n   */\n  get(options: { default: TValue }): TValue\n  /**\n   * Delete the box associated with this proxy if it exists.\n   * @returns True if the box existed and was deleted, else false\n   */\n  delete(): boolean\n  /**\n   * Get the value stored in the box if available, and a boolean indicating if the box exists.\n   *\n   * If the box does not exist, the value returned at position 0 should not be relied on to have a valid value.\n   * @returns A tuple with the first item being the box value, and the second item being a boolean indicating if the box exists.\n   */\n  maybe(): readonly [TValue, boolean]\n  /**\n   * Returns the length of the box, or error if the box does not exist\n   */\n  readonly length: uint64\n\n  /**\n   * Splice the specified bytes into the box starting at `start`, removing `length` bytes\n   * from the existing value and replacing them with `value` before appending the remainder of the original box value.\n   *\n   * If the resulting byte value is larger than length, bytes will be trimmed from the end\n   * If the resulting byte value is smaller than length, zero bytes will be appended to the end\n   * Error if the box does not exist\n   * @param start The index to start inserting the value\n   * @param length The number of bytes after `start` to be omitted\n   * @param value The value to be inserted\n   */\n  splice(start: uint64, length: uint64, value: bytes): void\n  /**\n   * Replace bytes in a box starting at `start`.\n   *\n   * Error if the box does not exist\n   * Error if `start` + `value.length` is greater than the box size\n   * @param start The index to start replacing\n   * @param value The value to be written\n   */\n  replace(start: uint64, value: bytes): void\n  /**\n   * Extract a slice of bytes from the box\n   *\n   * Error if the box does not exist\n   * Error if `start` + `length` is greater than the box size\n   * @param start The index to start extracting\n   * @param length The number of bytes to extract\n   * @returns The extracted bytes\n   */\n  extract(start: uint64, length: uint64): bytes\n  /**\n   * Resize the box to the specified size.\n   *\n   * Adds zero bytes to the end if the new size is larger\n   * Removes end bytes if the new size is smaller\n   * Error if the box does not exist\n   * @param newSize The new size for the box\n   */\n  resize(newSize: uint64): void\n}\n/**\n * A BoxMap proxy\n * @typeParam TKey The type of the value used to key each box.\n * @typeParam TValue The type of the data stored in the box.\n */\nexport type BoxMap<TKey, TValue> = {\n  /**\n   * Get the bytes used to prefix each key\n   */\n  readonly keyPrefix: bytes\n\n  /**\n   * Get a Box proxy for a single item in the BoxMap\n   * @param key The key of the box to retrieve a proxy for\n   */\n  (key: TKey): Box<TValue>\n}\n\n/**\n * Options for creating a Box proxy\n */\ninterface CreateBoxOptions {\n  /**\n   * The bytes which make up the key of the box\n   */\n  key: bytes | string\n}\n\n/**\n * Creates a Box proxy object offering methods of getting and setting the value stored in a single box.\n * @param options Options for creating the Box proxy\n * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.\n */\nexport function Box<TValue>(options: CreateBoxOptions): Box<TValue> {\n  throw new NoImplementation()\n}\n\n/**\n * Options for creating a BoxMap proxy\n */\ninterface CreateBoxMapOptions {\n  /**\n   * The bytes which prefix each key of the box map\n   */\n  keyPrefix: bytes | string\n}\n\n/**\n * Creates a BoxMap proxy object offering methods of getting and setting a set of values stored in individual boxes indexed by a common key type\n * @param options Options for creating the BoxMap proxy\n * @typeParam TKey The type of the value used to key each box. This key will be encoded to bytes and prefixed with `keyPrefix`\n * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.\n */\nexport function BoxMap<TKey, TValue>(options: CreateBoxMapOptions): BoxMap<TKey, TValue> {\n  throw new NoImplementation()\n}\n","import { NoImplementation } from './internal/errors'\nimport { bytes } from './primitives'\nimport { Account } from './reference'\n\n/**\n * A proxy for manipulating a global state field\n * @typeParam ValueType The type of the value being stored - must be a serializable type\n */\nexport type GlobalState<ValueType> = {\n  /**\n   * Get or set the value of this global state field\n   */\n  value: ValueType\n  /**\n   * Delete the stored value of this global state field\n   */\n  delete(): void\n  /**\n   * Gets a boolean value indicating if global state field currently has a value\n   */\n  readonly hasValue: boolean\n}\n/**\n * Options for declaring a global state field\n */\nexport type GlobalStateOptions<ValueType> = {\n  /**\n   * The key to be used for this global state field.\n   *\n   * Defaults to the name of the property this proxy is assigned to\n   */\n  key?: bytes | string\n  /**\n   * An initial value to assign to this global state field when the application is created\n   */\n  initialValue?: ValueType\n}\n\n/**\n * Creates a new proxy for manipulating a global state field\n * @param options Options for configuring this field\n * @typeParam ValueType The type of the value being stored - must be a serializable type\n */\nexport function GlobalState<ValueType>(options?: GlobalStateOptions<ValueType>): GlobalState<ValueType> {\n  throw new NoImplementation()\n}\n\n/**\n * A proxy for manipulating a local state field for a single account\n */\nexport type LocalStateForAccount<ValueType> = {\n  /**\n   * Get or set the value of this local state field for a single account\n   */\n  value: ValueType\n  /**\n   * Delete the stored value of this local state field for a single account\n   */\n  delete(): void\n  /**\n   * Gets a boolean value indicating if local state field for a single account currently has a value\n   */\n  readonly hasValue: boolean\n}\n\n/**\n * A proxy for manipulating a local state field for any account\n */\nexport type LocalState<ValueType> = {\n  /**\n   * Gets the LocalState proxy for a specific account\n   * @param account The account to read or write state for. This account must be opted into the contract\n   */\n  (account: Account): LocalStateForAccount<ValueType>\n}\n/**\n * Options for declaring a local state field\n */\nexport type LocalStateOptions = {\n  /**\n   * The key to be used for this local state field.\n   *\n   * Defaults to the name of the property this proxy is assigned to\n   */\n  key?: bytes | string\n}\n\n/**\n * Creates a new proxy for manipulating a local state field\n * @param options Options for configuring this field\n */\nexport function LocalState<ValueType>(options?: LocalStateOptions): LocalState<ValueType> {\n  throw new NoImplementation()\n}\n","/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */\nimport { NoImplementation } from './internal/errors'\nimport { OnCompleteAction } from './on-complete-action'\nimport { bytes, uint64 } from './primitives'\nimport { Account, Application, Asset } from './reference'\nimport { TransactionType } from './transactions'\n\nconst isItxn = Symbol('isItxn')\nexport namespace itxn {\n  /**\n   * An inner transaction of type 'pay'\n   */\n  export interface PaymentInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.Payment\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * 32 byte address\n     */\n    readonly receiver: Account\n    /**\n     * microalgos\n     */\n    readonly amount: uint64\n    /**\n     * 32 byte address\n     */\n    readonly closeRemainderTo: Account\n  }\n  /**\n   * An inner transaction of type 'keyreg'\n   */\n  export interface KeyRegistrationInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.KeyRegistration\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * 32 byte address\n     */\n    readonly voteKey: bytes<32>\n    /**\n     * 32 byte address\n     */\n    readonly selectionKey: bytes<32>\n    /**\n     * The first round that the participation key is valid.\n     */\n    readonly voteFirst: uint64\n    /**\n     * The last round that the participation key is valid.\n     */\n    readonly voteLast: uint64\n    /**\n     * Dilution for the 2-level participation key\n     */\n    readonly voteKeyDilution: uint64\n    /**\n     * Marks an account nonparticipating for rewards\n     */\n    readonly nonparticipation: boolean\n    /**\n     * 64 byte state proof public key\n     */\n    readonly stateProofKey: bytes<64>\n  }\n  /**\n   * An inner transaction of type 'acfg'\n   */\n  export interface AssetConfigInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetConfig\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID in asset config transaction\n     */\n    readonly configAsset: Asset\n    /**\n     * The asset created by this transaction\n     */\n    readonly createdAsset: Asset\n    /**\n     * Total number of units of this asset created\n     */\n    readonly total: uint64\n    /**\n     * Number of digits to display after the decimal place when displaying the asset\n     */\n    readonly decimals: uint64\n    /**\n     * Whether the asset's slots are frozen by default or not, 0 or 1\n     */\n    readonly defaultFrozen: boolean\n    /**\n     * Unit name of the asset\n     */\n    readonly unitName: bytes\n    /**\n     * The asset name\n     */\n    readonly assetName: bytes\n    /**\n     * URL\n     */\n    readonly url: bytes\n    /**\n     * 32 byte commitment to unspecified asset metadata\n     */\n    readonly metadataHash: bytes<32>\n    /**\n     * 32 byte address\n     */\n    readonly manager: Account\n    /**\n     * 32 byte address\n     */\n    readonly reserve: Account\n    /**\n     * 32 byte address\n     */\n    readonly freeze: Account\n    /**\n     * 32 byte address\n     */\n    readonly clawback: Account\n  }\n  /**\n   * An inner transaction of type 'axfer'\n   */\n  export interface AssetTransferInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetTransfer\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID\n     */\n    readonly xferAsset: Asset\n    /**\n     * value in Asset's units\n     */\n    readonly assetAmount: uint64\n    /**\n     * 32 byte address. Source of assets if Sender is the Asset's Clawback address.\n     */\n    readonly assetSender: Account\n    /**\n     * 32 byte address\n     */\n    readonly assetReceiver: Account\n    /**\n     * 32 byte address\n     */\n    readonly assetCloseTo: Account\n  }\n  /**\n   * An inner transaction of type 'afrz'\n   */\n  export interface AssetFreezeInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetFreeze\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID being frozen or un-frozen\n     */\n    readonly freezeAsset: Asset\n    /**\n     * 32 byte address of the account whose asset slot is being frozen or un-frozen\n     */\n    readonly freezeAccount: Account\n    /**\n     * The new frozen value\n     */\n    readonly frozen: boolean\n  }\n  /**\n   * An inner transaction of type 'appl'\n   */\n  export interface ApplicationCallInnerTxn {\n    /** @hidden */\n    [isItxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.ApplicationCall\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * ApplicationID from ApplicationCall transaction\n     */\n    readonly appId: Application\n    /**\n     * ApplicationCall transaction on completion action\n     */\n    readonly onCompletion: OnCompleteAction\n    /**\n     * Number of ApplicationArgs\n     */\n    readonly numAppArgs: uint64\n    /**\n     * Number of ApplicationArgs\n     */\n    readonly numAccounts: uint64\n    /**\n     * The first page of the Approval program\n     */\n    readonly approvalProgram: bytes\n    /**\n     * The first page of the Clear State program\n     */\n    readonly clearStateProgram: bytes\n    /**\n     * Number of Assets\n     */\n    readonly numAssets: uint64\n    /**\n     * Number of Applications\n     */\n    readonly numApps: uint64\n    /**\n     * Number of global state integers this application makes use of.\n     */\n    readonly globalNumUint: uint64\n    /**\n     * Number of global state byteslices this application makes use of.\n     */\n    readonly globalNumBytes: uint64\n    /**\n     * Number of local state integers this application makes use of.\n     */\n    readonly localNumUint: uint64\n    /**\n     * Number of local state byteslices this application makes use of.\n     */\n    readonly localNumBytes: uint64\n    /**\n     * Number of additional pages for each of the application's approval and clear state program\n     */\n    readonly extraProgramPages: uint64\n    /**\n     * The last message emitted. Empty bytes if none were emitted. App mode only\n     */\n    readonly lastLog: bytes\n    /**\n     * Read application logs\n     * @param index Index of the log to get\n     */\n    logs(index: uint64): bytes\n    /**\n     * Number of Approval Program pages\n     */\n    readonly numApprovalProgramPages: uint64\n    /**\n     * All approval program pages\n     * @param index Index of the page to get\n     */\n    approvalProgramPages(index: uint64): bytes\n    /**\n     * Number of Clear State Program pages\n     */\n    readonly numClearStateProgramPages: uint64\n    /**\n     * All clear state program pages\n     * @param index Index of the page to get\n     */\n    clearStateProgramPages(index: uint64): bytes\n    /**\n     * Arguments passed to the application in the ApplicationCall transaction\n     * @param index Index of the arg to get\n     */\n    appArgs(index: uint64): bytes\n    /**\n     * Accounts listed in the ApplicationCall transaction\n     * @param index Index of the account to get\n     */\n    accounts(index: uint64): Account\n    /**\n     * Foreign Assets listed in the ApplicationCall transaction\n     * @param index Index of the asset to get\n     */\n    assets(index: uint64): Asset\n    /**\n     * Foreign Apps listed in the ApplicationCall transaction\n     * @param index Index of the application to get\n     */\n    apps(index: uint64): Application\n    /**\n     * The id of the created application\n     */\n    readonly createdApp: Application\n    /**\n     * Number of logs\n     */\n    readonly numLogs: uint64\n    /**\n     * Application version for which the txn must reject\n     */\n    readonly rejectVersion: uint64\n  }\n  export interface PaymentFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    receiver?: Account | bytes\n    /**\n     * microalgos\n     */\n    amount?: uint64\n    /**\n     * 32 byte address\n     */\n    closeRemainderTo?: Account | bytes\n  }\n  export interface KeyRegistrationFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    voteKey?: bytes<32>\n    /**\n     * 32 byte address\n     */\n    selectionKey?: bytes<32>\n    /**\n     * The first round that the participation key is valid.\n     */\n    voteFirst?: uint64\n    /**\n     * The last round that the participation key is valid.\n     */\n    voteLast?: uint64\n    /**\n     * Dilution for the 2-level participation key\n     */\n    voteKeyDilution?: uint64\n    /**\n     * Marks an account nonparticipating for rewards\n     */\n    nonparticipation?: boolean\n    /**\n     * 64 byte state proof public key\n     */\n    stateProofKey?: bytes<64>\n  }\n  export interface AssetConfigFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * Asset ID in asset config transaction\n     */\n    configAsset?: Asset | uint64\n    /**\n     * Total number of units of this asset created\n     */\n    total?: uint64\n    /**\n     * Number of digits to display after the decimal place when displaying the asset\n     */\n    decimals?: uint64\n    /**\n     * Whether the asset's slots are frozen by default or not, 0 or 1\n     */\n    defaultFrozen?: boolean\n    /**\n     * Unit name of the asset\n     */\n    unitName?: bytes | string\n    /**\n     * The asset name\n     */\n    assetName?: bytes | string\n    /**\n     * URL\n     */\n    url?: bytes | string\n    /**\n     * 32 byte commitment to unspecified asset metadata\n     */\n    metadataHash?: bytes<32>\n    /**\n     * 32 byte address\n     */\n    manager?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    reserve?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    freeze?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    clawback?: Account | bytes\n  }\n  export interface AssetTransferFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * Asset ID\n     */\n    xferAsset?: Asset | uint64\n    /**\n     * value in Asset's units\n     */\n    assetAmount?: uint64\n    /**\n     * 32 byte address. Source of assets if Sender is the Asset's Clawback address.\n     */\n    assetSender?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    assetReceiver?: Account | bytes\n    /**\n     * 32 byte address\n     */\n    assetCloseTo?: Account | bytes\n  }\n  export interface AssetFreezeFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * Asset ID being frozen or un-frozen\n     */\n    freezeAsset?: Asset | uint64\n    /**\n     * 32 byte address of the account whose asset slot is being frozen or un-frozen\n     */\n    freezeAccount?: Account | bytes\n    /**\n     * The new frozen value\n     */\n    frozen?: boolean\n  }\n  export interface ApplicationCallFields {\n    /**\n     * 32 byte address\n     */\n    sender?: Account | bytes\n    /**\n     * microalgos\n     */\n    fee?: uint64\n    /**\n     * round number\n     */\n    firstValid?: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    firstValidTime?: uint64\n    /**\n     * round number\n     */\n    lastValid?: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    note?: bytes | string\n    /**\n     * 32 byte lease value\n     */\n    lease?: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    rekeyTo?: Account | bytes\n    /**\n     * ApplicationID from ApplicationCall transaction\n     */\n    appId?: Application | uint64\n    /**\n     * ApplicationCall transaction on completion action\n     */\n    onCompletion?: OnCompleteAction\n    /**\n     * Number of global state integers this application makes use of.\n     */\n    globalNumUint?: uint64\n    /**\n     * Number of global state byteslices this application makes use of.\n     */\n    globalNumBytes?: uint64\n    /**\n     * Number of local state integers this application makes use of.\n     */\n    localNumUint?: uint64\n    /**\n     * Number of local state byteslices this application makes use of.\n     */\n    localNumBytes?: uint64\n    /**\n     * Number of additional pages for each of the application's approval and clear state program\n     */\n    extraProgramPages?: uint64\n    /**\n     * All approval program pages\n     * @param index Index of the page to get\n     */\n    approvalProgram?: bytes | readonly [...bytes[]]\n    /**\n     * All clear state program pages\n     * @param index Index of the page to get\n     */\n    clearStateProgram?: bytes | readonly [...bytes[]]\n    /**\n     * Arguments passed to the application in the ApplicationCall transaction\n     * @param index Index of the arg to get\n     */\n    appArgs?: readonly [...unknown[]]\n    /**\n     * Accounts listed in the ApplicationCall transaction\n     * @param index Index of the account to get\n     */\n    accounts?: readonly [...(Account | bytes)[]]\n    /**\n     * Foreign Assets listed in the ApplicationCall transaction\n     * @param index Index of the asset to get\n     */\n    assets?: readonly [...(Asset | uint64)[]]\n    /**\n     * Foreign Apps listed in the ApplicationCall transaction\n     * @param index Index of the application to get\n     */\n    apps?: readonly [...(Application | uint64)[]]\n    /**\n     * Application version for which the txn must reject\n     */\n    rejectVersion?: uint64\n  }\n  /**\n   * A union of all ItxnParams types\n   */\n  export type ItxnParams =\n    | PaymentItxnParams\n    | KeyRegistrationItxnParams\n    | AssetConfigItxnParams\n    | AssetTransferItxnParams\n    | AssetFreezeItxnParams\n    | ApplicationCallItxnParams\n  /**\n   * Conditional type which returns the matching InnerTransaction types for a given tuple of ItxnParams types\n   */\n  export type TxnFor<TFields extends [...ItxnParams[]]> = TFields extends [\n    { submit(): infer TTxn },\n    ...infer TRest extends [...ItxnParams[]],\n  ]\n    ? readonly [TTxn, ...TxnFor<TRest>]\n    : []\n  /**\n   * Submit a group of ItxnParams objects and return the InnerTransaction results\n   */\n  export function submitGroup<TFields extends [...ItxnParams[]]>(...transactionFields: TFields): TxnFor<TFields> {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds Payment fields which can be updated, cloned, or submitted.\n   */\n  export abstract class PaymentItxnParams {\n    /**\n     * Submit an itxn with these fields and return the PaymentInnerTxn result\n     */\n    submit(): PaymentInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this PaymentItxnParams object\n     */\n    set(fields: PaymentFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this PaymentItxnParams object\n     */\n    copy(): PaymentItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new PaymentItxnParams object with the specified fields\n   */\n  export function payment(fields: PaymentFields): PaymentItxnParams {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds KeyRegistration fields which can be updated, cloned, or submitted.\n   */\n  export abstract class KeyRegistrationItxnParams {\n    /**\n     * Submit an itxn with these fields and return the KeyRegistrationInnerTxn result\n     */\n    submit(): KeyRegistrationInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this KeyRegistrationItxnParams object\n     */\n    set(fields: KeyRegistrationFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this KeyRegistrationItxnParams object\n     */\n    copy(): KeyRegistrationItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new KeyRegistrationItxnParams object with the specified fields\n   */\n  export function keyRegistration(fields: KeyRegistrationFields): KeyRegistrationItxnParams {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds AssetConfig fields which can be updated, cloned, or submitted.\n   */\n  export abstract class AssetConfigItxnParams {\n    /**\n     * Submit an itxn with these fields and return the AssetConfigInnerTxn result\n     */\n    submit(): AssetConfigInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this AssetConfigItxnParams object\n     */\n    set(fields: AssetConfigFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this AssetConfigItxnParams object\n     */\n    copy(): AssetConfigItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new AssetConfigItxnParams object with the specified fields\n   */\n  export function assetConfig(fields: AssetConfigFields): AssetConfigItxnParams {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds AssetTransfer fields which can be updated, cloned, or submitted.\n   */\n  export abstract class AssetTransferItxnParams {\n    /**\n     * Submit an itxn with these fields and return the AssetTransferInnerTxn result\n     */\n    submit(): AssetTransferInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this AssetTransferItxnParams object\n     */\n    set(fields: AssetTransferFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this AssetTransferItxnParams object\n     */\n    copy(): AssetTransferItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new AssetTransferItxnParams object with the specified fields\n   */\n  export function assetTransfer(fields: AssetTransferFields): AssetTransferItxnParams {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds AssetFreeze fields which can be updated, cloned, or submitted.\n   */\n  export abstract class AssetFreezeItxnParams {\n    /**\n     * Submit an itxn with these fields and return the AssetFreezeInnerTxn result\n     */\n    submit(): AssetFreezeInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this AssetFreezeItxnParams object\n     */\n    set(fields: AssetFreezeFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this AssetFreezeItxnParams object\n     */\n    copy(): AssetFreezeItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new AssetFreezeItxnParams object with the specified fields\n   */\n  export function assetFreeze(fields: AssetFreezeFields): AssetFreezeItxnParams {\n    throw new NoImplementation()\n  }\n  /**\n   * Holds ApplicationCall fields which can be updated, cloned, or submitted.\n   */\n  export abstract class ApplicationCallItxnParams {\n    /**\n     * Submit an itxn with these fields and return the ApplicationCallInnerTxn result\n     */\n    submit(): ApplicationCallInnerTxn {\n      throw new NoImplementation()\n    }\n    /**\n     * Update one or more fields in this ApplicationCallItxnParams object\n     */\n    set(fields: ApplicationCallFields): void {\n      throw new NoImplementation()\n    }\n    /**\n     * Return a copy of this ApplicationCallItxnParams object\n     */\n    copy(): ApplicationCallItxnParams {\n      throw new NoImplementation()\n    }\n  }\n  /**\n   * Create a new ApplicationCallItxnParams object with the specified fields\n   */\n  export function applicationCall(fields: ApplicationCallFields): ApplicationCallItxnParams {\n    throw new NoImplementation()\n  }\n}\n","import { Contract, TypedApplicationCallFields } from './arc4'\nimport { NoImplementation } from './internal/errors'\nimport { DeliberateAny, InstanceMethod } from './internal/typescript-helpers'\nimport { itxn } from './itxn'\nimport { TransactionType } from './transactions'\n\nexport interface PaymentComposeFields extends itxn.PaymentFields {\n  type: TransactionType.Payment\n}\nexport interface KeyRegistrationComposeFields extends itxn.KeyRegistrationFields {\n  type: TransactionType.KeyRegistration\n}\nexport interface AssetConfigComposeFields extends itxn.AssetConfigFields {\n  type: TransactionType.AssetConfig\n}\nexport interface AssetTransferComposeFields extends itxn.AssetTransferFields {\n  type: TransactionType.AssetTransfer\n}\nexport interface AssetFreezeComposeFields extends itxn.AssetFreezeFields {\n  type: TransactionType.AssetFreeze\n}\nexport interface ApplicationCallComposeFields extends itxn.ApplicationCallFields {\n  type: TransactionType.ApplicationCall\n}\n\nexport interface AnyTransactionComposeFields\n  extends itxn.PaymentFields,\n    itxn.KeyRegistrationFields,\n    itxn.AssetConfigFields,\n    itxn.AssetTransferFields,\n    itxn.AssetFreezeFields,\n    itxn.ApplicationCallFields {\n  type: TransactionType\n}\n\nexport type ComposeItxnParams =\n  | itxn.PaymentItxnParams\n  | itxn.KeyRegistrationItxnParams\n  | itxn.AssetConfigItxnParams\n  | itxn.AssetTransferItxnParams\n  | itxn.AssetFreezeItxnParams\n  | itxn.ApplicationCallItxnParams\n\nexport type ItxnCompose = {\n  begin(fields: PaymentComposeFields): void\n  begin(fields: KeyRegistrationComposeFields): void\n  begin(fields: AssetConfigComposeFields): void\n  begin(fields: AssetTransferComposeFields): void\n  begin(fields: AssetFreezeComposeFields): void\n  begin(fields: ApplicationCallComposeFields): void\n  begin(fields: AnyTransactionComposeFields): void\n  begin(fields: ComposeItxnParams): void\n  begin<TArgs extends DeliberateAny[]>(method: InstanceMethod<Contract, TArgs>, fields: TypedApplicationCallFields<TArgs>): void\n\n  next(fields: PaymentComposeFields): void\n  next(fields: KeyRegistrationComposeFields): void\n  next(fields: AssetConfigComposeFields): void\n  next(fields: AssetTransferComposeFields): void\n  next(fields: AssetFreezeComposeFields): void\n  next(fields: ApplicationCallComposeFields): void\n  next(fields: AnyTransactionComposeFields): void\n  next(fields: ComposeItxnParams): void\n  next<TArgs extends DeliberateAny[]>(method: InstanceMethod<Contract, TArgs>, fields: TypedApplicationCallFields<TArgs>): void\n\n  submit(): void\n}\n\nexport const itxnCompose: ItxnCompose = NoImplementation.value()\n","/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */\nimport { OnCompleteAction } from './on-complete-action'\nimport { bytes, uint64 } from './primitives'\nimport { Account, Application, Asset } from './reference'\nimport { TransactionType } from './transactions'\nimport { NoImplementation } from './internal/errors'\n\nconst isGtxn = Symbol('isGtxn')\nexport namespace gtxn {\n  /**\n   * A group transaction of type 'pay'\n   */\n  export interface PaymentTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.Payment\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * 32 byte address\n     */\n    readonly receiver: Account\n    /**\n     * microalgos\n     */\n    readonly amount: uint64\n    /**\n     * 32 byte address\n     */\n    readonly closeRemainderTo: Account\n  }\n  /**\n   * A group transaction of type 'keyreg'\n   */\n  export interface KeyRegistrationTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.KeyRegistration\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * 32 byte address\n     */\n    readonly voteKey: bytes<32>\n    /**\n     * 32 byte address\n     */\n    readonly selectionKey: bytes<32>\n    /**\n     * The first round that the participation key is valid.\n     */\n    readonly voteFirst: uint64\n    /**\n     * The last round that the participation key is valid.\n     */\n    readonly voteLast: uint64\n    /**\n     * Dilution for the 2-level participation key\n     */\n    readonly voteKeyDilution: uint64\n    /**\n     * Marks an account nonparticipating for rewards\n     */\n    readonly nonparticipation: boolean\n    /**\n     * 64 byte state proof public key\n     */\n    readonly stateProofKey: bytes<64>\n  }\n  /**\n   * A group transaction of type 'acfg'\n   */\n  export interface AssetConfigTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetConfig\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID in asset config transaction\n     */\n    readonly configAsset: Asset\n    /**\n     * The asset created by this transaction\n     */\n    readonly createdAsset: Asset\n    /**\n     * Total number of units of this asset created\n     */\n    readonly total: uint64\n    /**\n     * Number of digits to display after the decimal place when displaying the asset\n     */\n    readonly decimals: uint64\n    /**\n     * Whether the asset's slots are frozen by default or not, 0 or 1\n     */\n    readonly defaultFrozen: boolean\n    /**\n     * Unit name of the asset\n     */\n    readonly unitName: bytes\n    /**\n     * The asset name\n     */\n    readonly assetName: bytes\n    /**\n     * URL\n     */\n    readonly url: bytes\n    /**\n     * 32 byte commitment to unspecified asset metadata\n     */\n    readonly metadataHash: bytes<32>\n    /**\n     * 32 byte address\n     */\n    readonly manager: Account\n    /**\n     * 32 byte address\n     */\n    readonly reserve: Account\n    /**\n     * 32 byte address\n     */\n    readonly freeze: Account\n    /**\n     * 32 byte address\n     */\n    readonly clawback: Account\n  }\n  /**\n   * A group transaction of type 'axfer'\n   */\n  export interface AssetTransferTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetTransfer\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID\n     */\n    readonly xferAsset: Asset\n    /**\n     * value in Asset's units\n     */\n    readonly assetAmount: uint64\n    /**\n     * 32 byte address. Source of assets if Sender is the Asset's Clawback address.\n     */\n    readonly assetSender: Account\n    /**\n     * 32 byte address\n     */\n    readonly assetReceiver: Account\n    /**\n     * 32 byte address\n     */\n    readonly assetCloseTo: Account\n  }\n  /**\n   * A group transaction of type 'afrz'\n   */\n  export interface AssetFreezeTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.AssetFreeze\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * Asset ID being frozen or un-frozen\n     */\n    readonly freezeAsset: Asset\n    /**\n     * 32 byte address of the account whose asset slot is being frozen or un-frozen\n     */\n    readonly freezeAccount: Account\n    /**\n     * The new frozen value\n     */\n    readonly frozen: boolean\n  }\n  /**\n   * A group transaction of type 'appl'\n   */\n  export interface ApplicationCallTxn {\n    /** @hidden */\n    [isGtxn]?: true\n    /**\n     * 32 byte address\n     */\n    readonly sender: Account\n    /**\n     * microalgos\n     */\n    readonly fee: uint64\n    /**\n     * round number\n     */\n    readonly firstValid: uint64\n    /**\n     * UNIX timestamp of block before txn.FirstValid. Fails if negative\n     */\n    readonly firstValidTime: uint64\n    /**\n     * round number\n     */\n    readonly lastValid: uint64\n    /**\n     * Any data up to 1024 bytes\n     */\n    readonly note: bytes\n    /**\n     * 32 byte lease value\n     */\n    readonly lease: bytes<32>\n    /**\n     * Transaction type as bytes\n     */\n    readonly typeBytes: bytes\n    /**\n     * Transaction type\n     */\n    readonly type: TransactionType.ApplicationCall\n    /**\n     * Position of this transaction within an atomic group\n     * A stand-alone transaction is implicitly element 0 in a group of 1\n     */\n    readonly groupIndex: uint64\n    /**\n     * The computed ID for this transaction. 32 bytes.\n     */\n    readonly txnId: bytes<32>\n    /**\n     * 32 byte Sender's new AuthAddr\n     */\n    readonly rekeyTo: Account\n    /**\n     * ApplicationID from ApplicationCall transaction\n     */\n    readonly appId: Application\n    /**\n     * ApplicationCall transaction on completion action\n     */\n    readonly onCompletion: OnCompleteAction\n    /**\n     * Number of ApplicationArgs\n     */\n    readonly numAppArgs: uint64\n    /**\n     * Number of ApplicationArgs\n     */\n    readonly numAccounts: uint64\n    /**\n     * The first page of the Approval program\n     */\n    readonly approvalProgram: bytes\n    /**\n     * The first page of the Clear State program\n     */\n    readonly clearStateProgram: bytes\n    /**\n     * Number of Assets\n     */\n    readonly numAssets: uint64\n    /**\n     * Number of Applications\n     */\n    readonly numApps: uint64\n    /**\n     * Number of global state integers this application makes use of.\n     */\n    readonly globalNumUint: uint64\n    /**\n     * Number of global state byteslices this application makes use of.\n     */\n    readonly globalNumBytes: uint64\n    /**\n     * Number of local state integers this application makes use of.\n     */\n    readonly localNumUint: uint64\n    /**\n     * Number of local state byteslices this application makes use of.\n     */\n    readonly localNumBytes: uint64\n    /**\n     * Number of additional pages for each of the application's approval and clear state program\n     */\n    readonly extraProgramPages: uint64\n    /**\n     * The last message emitted. Empty bytes if none were emitted. App mode only\n     */\n    readonly lastLog: bytes\n    /**\n     * Read application logs\n     * @param index Index of the log to get\n     */\n    logs(index: uint64): bytes\n    /**\n     * Number of Approval Program pages\n     */\n    readonly numApprovalProgramPages: uint64\n    /**\n     * All approval program pages\n     * @param index Index of the page to get\n     */\n    approvalProgramPages(index: uint64): bytes\n    /**\n     * Number of Clear State Program pages\n     */\n    readonly numClearStateProgramPages: uint64\n    /**\n     * All clear state program pages\n     * @param index Index of the page to get\n     */\n    clearStateProgramPages(index: uint64): bytes\n    /**\n     * Arguments passed to the application in the ApplicationCall transaction\n     * @param index Index of the arg to get\n     */\n    appArgs(index: uint64): bytes\n    /**\n     * Accounts listed in the ApplicationCall transaction\n     * @param index Index of the account to get\n     */\n    accounts(index: uint64): Account\n    /**\n     * Foreign Assets listed in the ApplicationCall transaction\n     * @param index Index of the asset to get\n     */\n    assets(index: uint64): Asset\n    /**\n     * Foreign Apps listed in the ApplicationCall transaction\n     * @param index Index of the application to get\n     */\n    apps(index: uint64): Application\n    /**\n     * The id of the created application\n     */\n    readonly createdApp: Application\n    /**\n     * Number of logs\n     */\n    readonly numLogs: uint64\n    /**\n     * Application version for which the txn must reject\n     */\n    readonly rejectVersion: uint64\n  }\n  /**\n   * A group transaction of any type\n   */\n  export type Transaction = PaymentTxn | KeyRegistrationTxn | AssetConfigTxn | AssetTransferTxn | AssetFreezeTxn | ApplicationCallTxn\n  /**\n   * Get the nth transaction in the group without verifying its type\n   * @param n The index of the txn in the group\n   */\n  export function Transaction(n: uint64): Transaction {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'pay'\n   * @param n The index of the txn in the group\n   */\n  export function PaymentTxn(n: uint64): PaymentTxn {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'keyreg'\n   * @param n The index of the txn in the group\n   */\n  export function KeyRegistrationTxn(n: uint64): KeyRegistrationTxn {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'acfg'\n   * @param n The index of the txn in the group\n   */\n  export function AssetConfigTxn(n: uint64): AssetConfigTxn {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'axfer'\n   * @param n The index of the txn in the group\n   */\n  export function AssetTransferTxn(n: uint64): AssetTransferTxn {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'afrz'\n   * @param n The index of the txn in the group\n   */\n  export function AssetFreezeTxn(n: uint64): AssetFreezeTxn {\n    throw new NoImplementation()\n  }\n  /**\n   * Get the nth transaction in the group\n   * Verifies the txn type is 'appl'\n   * @param n The index of the txn in the group\n   */\n  export function ApplicationCallTxn(n: uint64): ApplicationCallTxn {\n    throw new NoImplementation()\n  }\n}\n","/**\n * The different transaction types available in a transaction\n */\nexport enum TransactionType {\n  /**\n   * A Payment transaction\n   */\n  Payment = 1,\n  /**\n   * A Key Registration transaction\n   */\n  KeyRegistration = 2,\n  /**\n   * An Asset Config transaction\n   */\n  AssetConfig = 3,\n  /**\n   * An Asset Transfer transaction\n   */\n  AssetTransfer = 4,\n  /**\n   * An Asset Freeze transaction\n   */\n  AssetFreeze = 5,\n  /**\n   * An Application Call transaction\n   */\n  ApplicationCall = 6,\n}\n","import { ConstructorFor } from './internal/typescript-helpers'\nimport { uint64 } from './primitives'\n\n/**\n * Base class for Algorand TypeScript Logic Signatures (also known as Smart Signatures)\n */\nexport abstract class LogicSig {\n  /**\n   * The logic signature program logic\n   */\n  abstract program(): boolean | uint64\n}\n\n/**\n * Alias for a numeric range specification.\n */\ntype NumberRange = {\n  /**\n   * The start point of the range (inclusive)\n   */\n  from: number\n  /**\n   * The end point of the range (inclusive)\n   */\n  to: number\n}\n\n/**\n * Defines optional configuration for a logic signature\n */\ntype LogicSigOptions = {\n  /**\n   * Determines which AVM version to use, this affects what operations are supported.\n   * Defaults to value provided on command line (which defaults to current mainnet version)\n   */\n  avmVersion?: 10 | 11 | 12 | 13\n  /**\n   * Override the name of the logic signature when generating build artifacts.\n   * Defaults to the class name\n   */\n  name?: string\n  /**\n   * Allows you to mark a slot ID or range of slot IDs as \"off limits\" to Puya.\n   * These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.\n   * This is particularly useful in combination with `op.gload_bytes` / `op.gload_uint64`\n   * which lets a contract in a group transaction read from the scratch slots of another contract\n   * that occurs earlier in the transaction group.\n   */\n  scratchSlots?: Array<number | NumberRange>\n}\n\n/**\n * The logicsig decorator can be used to specify additional configuration options for a logic signature\n * @param options An object containing the configuration options\n */\nexport function logicsig(options: LogicSigOptions) {\n  return <T extends ConstructorFor<LogicSig>>(logicSig: T) => logicSig\n}\n","import { NoImplementation } from './internal/errors'\n\n/**\n * Declare a template variable which can be replaced at compile time with an environment specific value.\n *\n * The final variable name will be `prefix + variableName`\n * @param variableName The key used to identify the variable.\n * @param prefix The prefix to apply the variable name (Defaults to 'TMPL_')\n */\nexport function TemplateVar<T>(variableName: string, prefix = 'TMPL_'): T {\n  throw new NoImplementation()\n}\n","import { BaseContract } from './base-contract'\nimport { NoImplementation } from './internal/errors'\nimport { ConstructorFor, DeliberateAny } from './internal/typescript-helpers'\nimport { LogicSig } from './logic-sig'\nimport { bytes, uint64 } from './primitives'\nimport { Account } from './reference'\n\n/**\n * Provides compiled programs and state allocation values for a Contract. Created by calling `compile(ExampleContractType)`\n */\nexport type CompiledContract = {\n  /**\n   * Approval program pages for a contract, after template variables have been replaced and compiled to AVM bytecode\n   */\n  readonly approvalProgram: readonly [bytes, bytes]\n  /**\n   * Clear state program pages for a contract, after template variables have been replaced and compiled to AVM bytecode\n   */\n  readonly clearStateProgram: readonly [bytes, bytes]\n  /**\n   * By default, provides extra program pages required based on approval and clear state program size, can be overridden when calling `compile(ExampleContractType, { extraProgramPages: ... })`\n   */\n  readonly extraProgramPages: uint64\n  /**\n   * By default, provides global num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalUints: ... })`\n   */\n  readonly globalUints: uint64\n  /**\n   * By default, provides global num bytes based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalBytes: ... })`\n   */\n  readonly globalBytes: uint64\n  /**\n   * By default, provides local num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { localUints: ... })`\n   */\n  readonly localUints: uint64\n  /**\n   * By default, provides local num bytes based on contract state totals, can be overridden  when calling `compile(ExampleContractType, { localBytes: ... })`\n   */\n  readonly localBytes: uint64\n}\n\n/**\n * Provides account for a Logic Signature. Created by calling `compile(LogicSigType)`\n */\nexport type CompiledLogicSig = {\n  /**\n   * Address of a logic sig program, after template variables have been replaced and compiled to AVM bytecode\n   */\n  readonly account: Account\n}\n\n/**\n * Options for compiling a contract\n */\nexport type CompileContractOptions = {\n  /**\n   * Number of extra program pages, defaults to minimum required for contract\n   */\n  readonly extraProgramPages?: uint64\n  /**\n   * Number of global uint64s, defaults to value defined for contract\n   */\n  readonly globalUints?: uint64\n  /**\n   * Number of global bytes, defaults to value defined for contract\n   */\n  readonly globalBytes?: uint64\n  /**\n   * Number of local uint64s, defaults to value defined for contract\n   */\n  readonly localUints?: uint64\n  /**\n   * Number of local bytes, defaults to value defined for contract\n   */\n  readonly localBytes?: uint64\n  /**\n   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant\n   * and match the type of the template var declaration\n   */\n  readonly templateVars?: Record<string, DeliberateAny>\n  /**\n   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)\n   */\n  readonly templateVarsPrefix?: string\n}\n\n/**\n * Options for compiling a logic signature\n */\nexport type CompileLogicSigOptions = {\n  /**\n   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant\n   * and match the type of the template var declaration\n   */\n  templateVars?: Record<string, DeliberateAny>\n  /**\n   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)\n   */\n  templateVarsPrefix?: string\n}\n\n/**\n * Compile a contract and return the resulting byte code for approval and clear state programs.\n * @param contract The contract class to compile\n * @param options Options for compiling the contract\n */\nexport function compile(contract: ConstructorFor<BaseContract>, options?: CompileContractOptions): CompiledContract\n/**\n * Compile a logic signature and return an account ready for signing transactions.\n * @param logicSig The logic sig class to compile\n * @param options Options for compiling the logic sig\n */\nexport function compile(logicSig: ConstructorFor<LogicSig>, options?: CompileLogicSigOptions): CompiledLogicSig\nexport function compile(artefact: ConstructorFor<BaseContract> | ConstructorFor<LogicSig>): CompiledLogicSig | CompiledContract {\n  throw new NoImplementation()\n}\n","import { NoImplementation } from './internal/errors'\nimport { uint64, Uint64Compat } from './primitives'\n\n/**\n * An in memory mutable array which is passed by reference\n */\nexport class ReferenceArray<TItem> {\n  /**\n   * Create a new ReferenceArray with the specified items\n   * @param items The initial items for the array\n   */\n  constructor(...items: TItem[]) {}\n\n  /**\n   * Returns the current length of this array\n   */\n  get length(): uint64 {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the item at the given index.\n   * Negative indexes are taken from the end.\n   * @param index The index of the item to retrieve\n   */\n  at(index: Uint64Compat): TItem {\n    throw new NoImplementation()\n  }\n\n  /**\n   * @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new ReferenceArray with all items from this array\n   */\n  slice(): ReferenceArray<TItem>\n  /**\n   * @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new ReferenceArray with all items up till `end`.\n   * Negative indexes are taken from the end.\n   * @param end An index in which to stop copying items.\n   */\n  slice(end: Uint64Compat): ReferenceArray<TItem>\n  /**\n   * @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new ReferenceArray with items from `start`, up until `end`\n   * Negative indexes are taken from the end.\n   * @param start An index in which to start copying items.\n   * @param end An index in which to stop copying items\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): ReferenceArray<TItem>\n  slice(start?: Uint64Compat, end?: Uint64Compat): ReferenceArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the items in this array\n   */\n  [Symbol.iterator](): IterableIterator<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for a tuple of the indexes and items in this array\n   */\n  entries(): IterableIterator<readonly [uint64, TItem]> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the indexes in this array\n   */\n  keys(): IterableIterator<uint64> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Get or set the item at the specified index.\n   * Negative indexes are not supported\n   */\n  [index: uint64]: TItem\n\n  /**\n   * Push a number of items into this array\n   * @param items The items to be added to this array\n   */\n  push(...items: TItem[]): void {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Pop a single item from this array\n   */\n  pop(): TItem {\n    throw new NoImplementation()\n  }\n}\n","import { NoImplementation } from './internal/errors'\nimport { DeliberateAny } from './internal/typescript-helpers'\n\n/**\n * Emit an arc28 event log using either an ARC4Struct type or a named object type.\n * Object types must have an ARC4 equivalent type.\n *\n * Anonymous types cannot be used as the type name is used to determine the event prefix\n * @param event An ARC4Struct instance, or a plain object with a named type\n *\n * @example\n * class Demo extends Struct<{ a: Uint64 }> {}\n * emit(new Demo({ a: new Uint64(123) }))\n *\n * @example\n * type Demo = { a: uint64 }\n * emit<Demo>({a: 123})\n * // or\n * const d: Demo = { a: 123 }\n * emit(d)\n */\nexport function emit<TEvent extends Record<string, DeliberateAny>>(event: TEvent): void\n/**\n * Emit an arc28 event log using an explicit name and inferred property/field types.\n * Property types must be ARC4 or have an ARC4 equivalent type.\n * @param eventName The name of the event (must be a compile time constant)\n * @param eventProps A set of event properties (order is significant)\n *\n * @example\n * emit(\"Demo\", new Uint64(123))\n *\n * @example\n * const a: uint64 = 123\n * emit(\"Demo\", a)\n */\nexport function emit<TProps extends [...DeliberateAny[]]>(eventName: string, ...eventProps: TProps): void\nexport function emit<T>(event: T | string, ...eventProps: unknown[]): void {\n  throw new NoImplementation()\n}\n","/**\n * The possible on complete actions a method can handle, represented as a string\n */\nexport type OnCompleteActionStr = 'NoOp' | 'OptIn' | 'ClearState' | 'CloseOut' | 'UpdateApplication' | 'DeleteApplication'\n\n/**\n * The possible on complete actions a method can handle, represented as an integer\n */\nexport enum OnCompleteAction {\n  /**\n   * Do nothing after the transaction has completed\n   */\n  NoOp = 0,\n  /**\n   * Opt the calling user into the contract\n   */\n  OptIn = 1,\n  /**\n   * Close the calling user out of the contract\n   */\n  CloseOut = 2,\n  /**\n   * Run the clear state program and forcibly close the user out of the contract\n   */\n  ClearState = 3,\n  /**\n   * Replace the application's approval and clear state programs with the bytes from this transaction\n   */\n  UpdateApplication = 4,\n  /**\n   * Delete the application\n   */\n  DeleteApplication = 5,\n}\n","import { NoImplementation } from './internal/errors'\nimport { uint64, Uint64Compat } from './primitives'\n\n/**\n * A fixed sized array\n * @typeParam TItem The type of a single item in the array\n * @typeParam TLength The fixed length of the array\n */\nexport class FixedArray<TItem, TLength extends number> implements ConcatArray<TItem> {\n  /**\n   * Create a new FixedArray instance\n   */\n  constructor()\n  /**\n   * Create a new FixedArray instance with the specified items\n   * @param items The initial items for the array\n   */\n  constructor(...items: TItem[] & { length: TLength })\n  constructor(...items: TItem[] & { length: TLength }) {}\n\n  /**\n   * Returns a new array containing all items from _this_ array, and _other_ array\n   * @param items Another array to concat with this one\n   */\n  concat(...items: (TItem | ConcatArray<TItem>)[]): TItem[] {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the statically declared length of this array\n   */\n  get length(): uint64 {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the item at the given index.\n   * Negative indexes are taken from the end.\n   * @param index The index of the item to retrieve\n   */\n  at(index: Uint64Compat): TItem {\n    throw new NoImplementation()\n  }\n\n  /** @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new Dynamic array with all items from this array\n   */\n  slice(): Array<TItem>\n  /** @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new DynamicArray with all items up till `end`.\n   * Negative indexes are taken from the end.\n   * @param end An index in which to stop copying items.\n   */\n  slice(end: Uint64Compat): Array<TItem>\n  /** @deprecated Array slicing is not yet supported in Algorand TypeScript\n   * Create a new DynamicArray with items from `start`, up until `end`\n   * Negative indexes are taken from the end.\n   * @param start An index in which to start copying items.\n   * @param end An index in which to stop copying items\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): Array<TItem>\n  slice(start?: Uint64Compat, end?: Uint64Compat): Array<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the items in this array\n   */\n  [Symbol.iterator](): IterableIterator<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for a tuple of the indexes and items in this array\n   */\n  entries(): ArrayIterator<readonly [uint64, TItem]> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the indexes in this array\n   */\n  keys(): IterableIterator<uint64> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Get or set the item at the specified index.\n   * Negative indexes are not supported\n   */\n  [index: uint64]: TItem\n\n  /**\n   * Creates a string by concatenating all the items in the array delimited by the\n   * specified separator (or ',' by default)\n   * @param separator\n   * @deprecated Join is not supported in Algorand TypeScript\n   */\n  join(separator?: string): string {\n    throw new NoImplementation()\n  }\n}\n"],"names":[],"mappings":"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"}